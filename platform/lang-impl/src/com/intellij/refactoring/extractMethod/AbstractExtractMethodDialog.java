// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.refactoring.extractMethod;

import com.intellij.codeInsight.codeFragment.CodeFragment;
import com.intellij.ide.util.PropertiesComponent;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.fileTypes.FileType;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.openapi.ui.Messages;
import com.intellij.refactoring.RefactoringBundle;
import com.intellij.refactoring.ui.ComboBoxVisibilityPanel;
import com.intellij.refactoring.ui.MethodSignatureComponent;
import com.intellij.refactoring.util.AbstractParameterTablePanel;
import com.intellij.refactoring.util.AbstractParameterTablePanel.NameColumnInfo;
import com.intellij.refactoring.util.AbstractParameterTablePanel.PassParameterColumnInfo;
import com.intellij.refactoring.util.AbstractVariableData;
import com.intellij.ui.DocumentAdapter;
import com.intellij.ui.IdeBorderFactory;
import com.intellij.ui.TitledSeparator;
import com.intellij.ui.components.JBScrollPane;
import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import com.intellij.util.ui.ColumnInfo;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.Action;
import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.border.TitledBorder;
import javax.swing.event.DocumentEvent;
import java.awt.Dimension;
import java.awt.Insets;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.ResourceBundle;
import java.util.stream.Stream;

public class AbstractExtractMethodDialog<T> extends DialogWrapper implements ExtractMethodSettings<T> {
  private final JPanel myContentPane;
  private final AbstractParameterTablePanel<AbstractVariableData> myParametersPanel;
  private final JTextField myMethodNameTextField;
  protected final MethodSignatureComponent mySignaturePreviewTextArea;
  private final JTextArea myOutputVariablesTextArea;
  private final ComboBoxVisibilityPanel<T> myVisibilityComboBox;
  protected final Project myProject;
  private final String myDefaultName;
  protected final CodeFragment myFragment;
  protected final ExtractMethodValidator myValidator;
  protected final ExtractMethodDecorator<T> myDecorator;

  protected AbstractVariableData[] myVariableData;
  private Map<String, AbstractVariableData> myVariablesMap;

  private final List<String> myArguments;
  private final ArrayList<String> myOutputVariables;
  private final FileType myFileType;

  public AbstractExtractMethodDialog(final Project project,
                                     final String defaultName,
                                     final CodeFragment fragment,
                                     final T[] visibilityVariants,
                                     final ExtractMethodValidator validator,
                                     final ExtractMethodDecorator<T> decorator,
                                     final FileType type) {
    super(project, true);
    myProject = project;
    myDefaultName = defaultName;
    myFragment = fragment;
    myValidator = validator;
    myDecorator = decorator;
    myFileType = type;

    myVisibilityComboBox = new ComboBoxVisibilityPanel<>(visibilityVariants);
    myVisibilityComboBox.setVisible(visibilityVariants.length > 1);
    getRememberedVisibility(visibilityVariants).ifPresent(myVisibilityComboBox::setVisibility);
    myVisibilityComboBox.addListener(event -> rememberCurrentVisibility());

    {
      myParametersPanel =
        new AbstractParameterTablePanel<>(getParameterColumns()) {

          @Override
          protected void doCancelAction() {
            AbstractExtractMethodDialog.this.doCancelAction();
          }

          @Override
          protected void doEnterAction() {
            doOKAction();
          }

          @Override
          protected void updateSignature() {
            updateOutputVariables();
            AbstractExtractMethodDialog.this.updateSignature();
          }
        };
      mySignaturePreviewTextArea = new MethodSignatureComponent("", myProject, myFileType);
    }
    {
      // GUI initializer generated by IntelliJ IDEA GUI Designer
      // >>> IMPORTANT!! <<<
      // DO NOT EDIT OR ADD ANY CODE HERE!
      myContentPane = new JPanel();
      myContentPane.setLayout(new GridLayoutManager(6, 1, new Insets(0, 0, 0, 0), -1, -1));
      final JPanel panel1 = new JPanel();
      panel1.setLayout(new GridLayoutManager(2, 2, new Insets(0, 0, 0, 0), -1, -1));
      myContentPane.add(panel1,
                        new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, 1, 1, null, null, null, 0,
                                            false));
      myMethodNameTextField = new JTextField();
      myMethodNameTextField.setColumns(10);
      myMethodNameTextField.setHorizontalAlignment(2);
      panel1.add(myMethodNameTextField, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL,
                                                            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW,
                                                            GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0,
                                                            false));
      final JLabel label1 = new JLabel();
      this.$$$loadLabelText$$$(label1, this.$$$getMessageFromBundle$$$("messages/RefactoringBundle",
                                                                       "refactoring.extract.method.dialog.method.name"));
      panel1.add(label1,
                 new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                     GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      panel1.add(myVisibilityComboBox, new GridConstraints(0, 0, 2, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
                                                           GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null,
                                                           null, null, 0, false));
      final JPanel panel2 = new JPanel();
      panel2.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
      panel2.putClientProperty("BorderFactoryClass", "com.intellij.ui.IdeBorderFactory$PlainSmallWithoutIndent");
      myContentPane.add(panel2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, 1,
                                                    GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null,
                                                    null, 0, false));
      panel2.setBorder(IdeBorderFactory.PlainSmallWithoutIndent.createTitledBorder(BorderFactory.createEtchedBorder(),
                                                                                   this.$$$getMessageFromBundle$$$(
                                                                                     "messages/RefactoringBundle",
                                                                                     "refactoring.extract.method.dialog.parameters"),
                                                                                   TitledBorder.DEFAULT_JUSTIFICATION,
                                                                                   TitledBorder.DEFAULT_POSITION, null, null));
      panel2.add(myParametersPanel, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, 1,
                                                        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null,
                                                        null, null, 0, false));
      final JBScrollPane jBScrollPane1 = new JBScrollPane();
      myContentPane.add(jBScrollPane1,
                        new GridConstraints(3, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, 1, 1, null, null, null, 0,
                                            false));
      jBScrollPane1.setViewportView(mySignaturePreviewTextArea);
      final JBScrollPane jBScrollPane2 = new JBScrollPane();
      myContentPane.add(jBScrollPane2,
                        new GridConstraints(5, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, 1, 1, null, null, null, 0,
                                            false));
      myOutputVariablesTextArea = new JTextArea();
      myOutputVariablesTextArea.setEditable(false);
      jBScrollPane2.setViewportView(myOutputVariablesTextArea);
      final TitledSeparator titledSeparator1 = new TitledSeparator();
      titledSeparator1.setText(
        this.$$$getMessageFromBundle$$$("messages/RefactoringBundle", "refactoring.extract.method.dialog.signature.preview"));
      titledSeparator1.putClientProperty("BorderFactoryClass", "");
      myContentPane.add(titledSeparator1, new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_SOUTH, GridConstraints.FILL_HORIZONTAL,
                                                              GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                                                              GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      final TitledSeparator titledSeparator2 = new TitledSeparator();
      titledSeparator2.setText(
        this.$$$getMessageFromBundle$$$("messages/RefactoringBundle", "refactoring.extract.method.dialog.output.variables"));
      titledSeparator2.putClientProperty("BorderFactoryClass", "");
      myContentPane.add(titledSeparator2, new GridConstraints(4, 0, 1, 1, GridConstraints.ANCHOR_SOUTH, GridConstraints.FILL_HORIZONTAL,
                                                              GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                                                              GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
    }

    myArguments = new ArrayList<>(fragment.getInputVariables());
    Collections.sort(myArguments);
    myOutputVariables = new ArrayList<>(fragment.getOutputVariables());
    Collections.sort(myOutputVariables);
    setModal(true);
    setTitle(RefactoringBundle.message("extract.method.title"));
    init();
  }

  private static Method $$$cachedGetBundleMethod$$$ = null;

  /** @noinspection ALL */
  private String $$$getMessageFromBundle$$$(String path, String key) {
    ResourceBundle bundle;
    try {
      Class<?> thisClass = this.getClass();
      if ($$$cachedGetBundleMethod$$$ == null) {
        Class<?> dynamicBundleClass = thisClass.getClassLoader().loadClass("com.intellij.DynamicBundle");
        $$$cachedGetBundleMethod$$$ = dynamicBundleClass.getMethod("getBundle", String.class, Class.class);
      }
      bundle = (ResourceBundle)$$$cachedGetBundleMethod$$$.invoke(null, path, thisClass);
    }
    catch (Exception e) {
      bundle = ResourceBundle.getBundle(path);
    }
    return bundle.getString(key);
  }

  /** @noinspection ALL */
  private void $$$loadLabelText$$$(JLabel component, String text) {
    StringBuffer result = new StringBuffer();
    boolean haveMnemonic = false;
    char mnemonic = '\0';
    int mnemonicIndex = -1;
    for (int i = 0; i < text.length(); i++) {
      if (text.charAt(i) == '&') {
        i++;
        if (i == text.length()) break;
        if (!haveMnemonic && text.charAt(i) != '&') {
          haveMnemonic = true;
          mnemonic = text.charAt(i);
          mnemonicIndex = result.length();
        }
      }
      result.append(text.charAt(i));
    }
    component.setText(result.toString());
    if (haveMnemonic) {
      component.setDisplayedMnemonic(mnemonic);
      component.setDisplayedMnemonicIndex(mnemonicIndex);
    }
  }

  /** @noinspection ALL */
  public JComponent $$$getRootComponent$$$() { return myContentPane; }

  @Override
  protected void init() {
    super.init();
    // Set default name and select it
    myMethodNameTextField.setText(myDefaultName);
    myMethodNameTextField.setSelectionStart(0);
    myMethodNameTextField.setSelectionStart(myDefaultName.length());
    myMethodNameTextField.getDocument().addDocumentListener(new DocumentAdapter() {
      @Override
      protected void textChanged(@NotNull DocumentEvent e) {
        updateOutputVariables();
        updateSignature();
        updateOkStatus();
      }
    });


    myVariableData = innerCreateVariableDataByNames(myArguments);
    myVariablesMap = createVariableMap(myVariableData);
    myParametersPanel.init(myVariableData);

    updateOutputVariables();
    updateSignature();
    updateOkStatus();
  }

  @Override
  public JComponent getPreferredFocusedComponent() {
    return myMethodNameTextField;
  }

  @NotNull
  protected AbstractVariableData @NotNull [] innerCreateVariableDataByNames(final @NotNull List<String> args) {
    return createVariableDataByNames(args);
  }

  public static AbstractVariableData[] createVariableDataByNames(final List<String> args) {
    final AbstractVariableData[] datas = new AbstractVariableData[args.size()];
    for (int i = 0; i < args.size(); i++) {
      final AbstractVariableData data = new AbstractVariableData();
      final String name = args.get(i);
      data.originalName = name;
      data.name = name;
      data.passAsParameter = true;
      datas[i] = data;
    }
    return datas;
  }

  public static Map<String, AbstractVariableData> createVariableMap(final AbstractVariableData[] data) {
    final HashMap<String, AbstractVariableData> map = new HashMap<>();
    for (AbstractVariableData variableData : data) {
      map.put(variableData.getOriginalName(), variableData);
    }
    return map;
  }

  @Override
  protected Action @NotNull [] createActions() {
    return new Action[]{getOKAction(), getCancelAction(), getHelpAction()};
  }

  @Override
  protected void doOKAction() {
    final String error = myValidator.check(getMethodName());
    if (error != null) {
      if (ApplicationManager.getApplication().isUnitTestMode()) {
        Messages.showInfoMessage(error, RefactoringBundle.message("error.title"));
        return;
      }
      if (Messages.showOkCancelDialog(error + ". " + RefactoringBundle.message("do.you.wish.to.continue"),
                                      RefactoringBundle.message("warning.title"), Messages.getWarningIcon()) != Messages.OK) {
        return;
      }
    }
    super.doOKAction();
  }

  @Override
  protected String getHelpId() {
    return "refactoring.extractMethod";
  }

  @Override
  protected JComponent createCenterPanel() {
    return myContentPane;
  }

  protected @NotNull ColumnInfo @NotNull [] getParameterColumns() {
    return new ColumnInfo[]{new PassParameterColumnInfo(), new NameColumnInfo(myValidator::isValidName)};
  }

  private @NotNull String getPersistenceId() {
    return "visibility.combobox." + getClass().getName();
  }

  private void rememberCurrentVisibility() {
    PropertiesComponent.getInstance().setValue(getPersistenceId(), Optional.ofNullable(getVisibility()).map(Object::toString).orElse(null));
  }

  private Optional<T> getRememberedVisibility(T[] visibilityVariants) {
    final String stringValue = PropertiesComponent.getInstance().getValue(getPersistenceId());
    return Stream.of(visibilityVariants).filter(visibility -> visibility.toString().equals(stringValue)).findAny();
  }

  private void updateOutputVariables() {
    final StringBuilder builder = new StringBuilder();
    boolean first = true;
    for (String variable : myOutputVariables) {
      if (myVariablesMap != null) {
        final AbstractVariableData data = myVariablesMap.get(variable);
        final String outputName = data != null ? data.getName() : variable;
        if (first) {
          first = false;
        }
        else {
          builder.append(", ");
        }
        builder.append(outputName);
      }
    }
    myOutputVariablesTextArea.setText(
      !builder.isEmpty() ? builder.toString() : RefactoringBundle.message("refactoring.extract.method.dialog.empty"));
  }

  protected void updateSignature() {
    mySignaturePreviewTextArea.setSignature(myDecorator.createMethodSignature(this));
  }

  private void updateOkStatus() {
    setOKActionEnabled(myValidator.isValidName(getMethodName()));
  }

  @Override
  public @NotNull String getMethodName() {
    return myMethodNameTextField.getText().trim();
  }

  @Override
  public AbstractVariableData @NotNull [] getAbstractVariableData() {
    return myVariableData;
  }

  @Override
  public @Nullable T getVisibility() {
    return myVisibilityComboBox.getVisibility();
  }
}