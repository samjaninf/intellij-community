// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.application.options.colors;

import com.intellij.ide.IdeBundle;
import com.intellij.openapi.application.ApplicationBundle;
import com.intellij.openapi.editor.colors.EditorColorsScheme;
import com.intellij.openapi.editor.colors.EditorSchemeAttributeDescriptor;
import com.intellij.openapi.editor.colors.EditorSchemeAttributeDescriptorWithPath;
import com.intellij.openapi.editor.markup.EffectType;
import com.intellij.openapi.editor.markup.TextAttributes;
import com.intellij.openapi.options.colors.AbstractKeyDescriptor;
import com.intellij.openapi.options.colors.ColorAndFontDescriptorsProvider;
import com.intellij.openapi.ui.ComboBox;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.util.NlsSafe;
import com.intellij.openapi.util.Pair;
import com.intellij.openapi.util.text.HtmlChunk;
import com.intellij.ui.CollectionComboBoxModel;
import com.intellij.ui.ColorPanel;
import com.intellij.ui.JBColor;
import com.intellij.ui.components.JBCheckBox;
import com.intellij.ui.components.JBScrollPane;
import com.intellij.ui.dsl.listCellRenderer.BuilderKt;
import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import com.intellij.uiDesigner.core.Spacer;
import com.intellij.util.BitUtil;
import com.intellij.util.EventDispatcher;
import com.intellij.util.FontUtil;
import com.intellij.util.containers.ContainerUtil;
import com.intellij.util.ui.JBUI;
import com.intellij.util.ui.StartupUiUtil;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.AbstractButton;
import javax.swing.BorderFactory;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextPane;
import javax.swing.border.TitledBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.Insets;
import java.awt.event.ActionListener;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.ResourceBundle;

public final class ColorAndFontDescriptionPanel extends JPanel implements OptionsPanelImpl.ColorDescriptionPanel {
  private final EventDispatcher<Listener> myDispatcher = EventDispatcher.create(Listener.class);

  private final JPanel myPanel;

  private final ColorPanel myBackgroundChooser;
  private final ColorPanel myForegroundChooser;
  private final ColorPanel myEffectsColorChooser;
  private final ColorPanel myErrorStripeColorChooser;

  private final JBCheckBox myCbBackground;
  private final JBCheckBox myCbForeground;
  private final JBCheckBox myCbEffects;
  private final JBCheckBox myCbErrorStripe;

  private final Map<String, EffectType> myEffectsMap;

  {
    Map<String, EffectType> map = new LinkedHashMap<>();
    map.put(ApplicationBundle.message("combobox.effect.underscored"), EffectType.LINE_UNDERSCORE);
    map.put(ApplicationBundle.message("combobox.effect.boldunderscored"), EffectType.BOLD_LINE_UNDERSCORE);
    map.put(ApplicationBundle.message("combobox.effect.underwaved"), EffectType.WAVE_UNDERSCORE);
    map.put(ApplicationBundle.message("combobox.effect.bordered"), EffectType.BOXED);
    map.put(ApplicationBundle.message("combobox.effect.strikeout"), EffectType.STRIKEOUT);
    map.put(ApplicationBundle.message("combobox.effect.bold.dottedline"), EffectType.BOLD_DOTTED_LINE);
    map.put(ApplicationBundle.message("combobox.effect.faded"), EffectType.FADED);
    myEffectsMap = Collections.unmodifiableMap(map);
  }

  private final JComboBox<String> myEffectsCombo;

  private final JBCheckBox myCbBold;
  private final JBCheckBox myCbItalic;
  private final JLabel myLabelFont;
  private final JTextPane myInheritanceLabel;

  private final JBCheckBox myInheritAttributesBox;
  private boolean myUiEventsEnabled = true;

  public ColorAndFontDescriptionPanel() {
    super(new BorderLayout());
    {
      // GUI initializer generated by IntelliJ IDEA GUI Designer
      // >>> IMPORTANT!! <<<
      // DO NOT EDIT OR ADD ANY CODE HERE!
      myPanel = new JPanel();
      myPanel.setLayout(new GridLayoutManager(10, 3, new Insets(0, 10, 10, 10), -1, -1));
      myCbForeground = new JBCheckBox();
      this.$$$loadButtonText$$$(myCbForeground, this.$$$getMessageFromBundle$$$("messages/ApplicationBundle", "checkbox.color.foreground"));
      myPanel.add(myCbForeground,
                  new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                      GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      myCbBackground = new JBCheckBox();
      this.$$$loadButtonText$$$(myCbBackground, this.$$$getMessageFromBundle$$$("messages/ApplicationBundle", "checkbox.color.background"));
      myPanel.add(myCbBackground,
                  new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                      GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      myCbErrorStripe = new JBCheckBox();
      this.$$$loadButtonText$$$(myCbErrorStripe,
                                this.$$$getMessageFromBundle$$$("messages/ApplicationBundle", "checkbox.color.error.stripe.mark"));
      myPanel.add(myCbErrorStripe,
                  new GridConstraints(3, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                      GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      myCbEffects = new JBCheckBox();
      this.$$$loadButtonText$$$(myCbEffects, this.$$$getMessageFromBundle$$$("messages/ApplicationBundle", "checkbox.color.effects"));
      myPanel.add(myCbEffects,
                  new GridConstraints(4, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                      GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      myForegroundChooser = new ColorPanel();
      myPanel.add(myForegroundChooser, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_EAST, GridConstraints.FILL_VERTICAL,
                                                           GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null,
                                                           null, 0, false));
      myBackgroundChooser = new ColorPanel();
      myPanel.add(myBackgroundChooser, new GridConstraints(2, 1, 1, 1, GridConstraints.ANCHOR_EAST, GridConstraints.FILL_VERTICAL,
                                                           GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null,
                                                           null, 0, false));
      myErrorStripeColorChooser = new ColorPanel();
      myPanel.add(myErrorStripeColorChooser, new GridConstraints(3, 1, 1, 1, GridConstraints.ANCHOR_EAST, GridConstraints.FILL_VERTICAL,
                                                                 GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null,
                                                                 null, null, 0, false));
      myEffectsColorChooser = new ColorPanel();
      myPanel.add(myEffectsColorChooser, new GridConstraints(4, 1, 1, 1, GridConstraints.ANCHOR_EAST, GridConstraints.FILL_VERTICAL,
                                                             GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null,
                                                             null, 0, false));
      final JPanel panel1 = new JPanel();
      panel1.setLayout(new GridLayoutManager(2, 1, new Insets(30, 0, 0, 0), -1, -1));
      myPanel.add(panel1, new GridConstraints(6, 0, 3, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,
                                              GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0,
                                              true));
      myInheritAttributesBox = new JBCheckBox();
      this.$$$loadButtonText$$$(myInheritAttributesBox,
                                this.$$$getMessageFromBundle$$$("messages/ApplicationBundle", "label.inherit.attributes"));
      panel1.add(myInheritAttributesBox,
                 new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                     GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      final JBScrollPane jBScrollPane1 = new JBScrollPane();
      panel1.add(jBScrollPane1, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,
                                                    GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                                                    GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null,
                                                    null, 0, false));
      jBScrollPane1.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(), null, TitledBorder.DEFAULT_JUSTIFICATION,
                                                               TitledBorder.DEFAULT_POSITION, null, null));
      myInheritanceLabel = new JTextPane();
      myInheritanceLabel.setText("labl"); //NON-NLS
      jBScrollPane1.setViewportView(myInheritanceLabel);
      final JPanel panel2 = new JPanel();
      panel2.setLayout(new GridLayoutManager(1, 3, new Insets(0, 0, 0, 0), -1, -1));
      myPanel.add(panel2, new GridConstraints(0, 0, 1, 2, GridConstraints.ANCHOR_EAST, GridConstraints.FILL_VERTICAL,
                                              GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0,
                                              false));
      myCbBold = new JBCheckBox();
      this.$$$loadButtonText$$$(myCbBold, this.$$$getMessageFromBundle$$$("messages/ApplicationBundle", "checkbox.font.bold"));
      panel2.add(myCbBold,
                 new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_EAST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                     GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      myCbItalic = new JBCheckBox();
      this.$$$loadButtonText$$$(myCbItalic, this.$$$getMessageFromBundle$$$("messages/ApplicationBundle", "checkbox.font.italic"));
      panel2.add(myCbItalic,
                 new GridConstraints(0, 2, 1, 1, GridConstraints.ANCHOR_EAST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                     GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      myLabelFont = new JLabel();
      this.$$$loadLabelText$$$(myLabelFont, this.$$$getMessageFromBundle$$$("messages/ApplicationBundle", "label.font.type"));
      panel2.add(myLabelFont,
                 new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                     GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      myEffectsCombo = new ComboBox();
      myPanel.add(myEffectsCombo, new GridConstraints(5, 0, 1, 2, GridConstraints.ANCHOR_EAST, GridConstraints.FILL_NONE,
                                                      GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                                                      GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      final Spacer spacer1 = new Spacer();
      myPanel.add(spacer1, new GridConstraints(8, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
                                               GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));
      final Spacer spacer2 = new Spacer();
      myPanel.add(spacer2, new GridConstraints(9, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_VERTICAL, 1,
                                               GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
    }
    add(myPanel, BorderLayout.CENTER);

    setBorder(JBUI.Borders.empty(4, 0, 4, 4));
    myEffectsCombo.setModel(new CollectionComboBoxModel<>(new ArrayList<>(myEffectsMap.keySet())));
    myEffectsCombo.setRenderer(BuilderKt.textListCellRenderer(IdeBundle.message("label.invalid.color"), s -> s));

    ActionListener actionListener = e -> {
      if (myUiEventsEnabled) {
        myErrorStripeColorChooser.setEnabled(myCbErrorStripe.isSelected());
        myForegroundChooser.setEnabled(myCbForeground.isSelected());
        myBackgroundChooser.setEnabled(myCbBackground.isSelected());
        myEffectsColorChooser.setEnabled(myCbEffects.isSelected());
        myEffectsCombo.setEnabled(myCbEffects.isSelected());

        myDispatcher.getMulticaster().onSettingsChanged(e);
      }
    };

    for (JBCheckBox c : new JBCheckBox[]{myCbBackground, myCbForeground, myCbEffects, myCbErrorStripe, myCbItalic, myCbBold,
      myInheritAttributesBox}) {
      c.addActionListener(actionListener);
    }
    for (ColorPanel c : new ColorPanel[]{myBackgroundChooser, myForegroundChooser, myEffectsColorChooser, myErrorStripeColorChooser}) {
      c.addActionListener(actionListener);
    }
    myEffectsCombo.addActionListener(actionListener);

    //noinspection HardCodedStringLiteral
    Messages.configureMessagePaneUi(myInheritanceLabel, "<html>", null);
    myInheritanceLabel.addHyperlinkListener(e -> myDispatcher.getMulticaster().onHyperLinkClicked(e));
    myInheritanceLabel.setBorder(JBUI.Borders.empty(4, 0, 4, 4));
    myLabelFont.setVisible(false); // hide for now as it doesn't look that good
  }

  private static Method $$$cachedGetBundleMethod$$$ = null;

  /** @noinspection ALL */
  private String $$$getMessageFromBundle$$$(String path, String key) {
    ResourceBundle bundle;
    try {
      Class<?> thisClass = this.getClass();
      if ($$$cachedGetBundleMethod$$$ == null) {
        Class<?> dynamicBundleClass = thisClass.getClassLoader().loadClass("com.intellij.DynamicBundle");
        $$$cachedGetBundleMethod$$$ = dynamicBundleClass.getMethod("getBundle", String.class, Class.class);
      }
      bundle = (ResourceBundle)$$$cachedGetBundleMethod$$$.invoke(null, path, thisClass);
    }
    catch (Exception e) {
      bundle = ResourceBundle.getBundle(path);
    }
    return bundle.getString(key);
  }

  /** @noinspection ALL */
  private void $$$loadLabelText$$$(JLabel component, String text) {
    StringBuffer result = new StringBuffer();
    boolean haveMnemonic = false;
    char mnemonic = '\0';
    int mnemonicIndex = -1;
    for (int i = 0; i < text.length(); i++) {
      if (text.charAt(i) == '&') {
        i++;
        if (i == text.length()) break;
        if (!haveMnemonic && text.charAt(i) != '&') {
          haveMnemonic = true;
          mnemonic = text.charAt(i);
          mnemonicIndex = result.length();
        }
      }
      result.append(text.charAt(i));
    }
    component.setText(result.toString());
    if (haveMnemonic) {
      component.setDisplayedMnemonic(mnemonic);
      component.setDisplayedMnemonicIndex(mnemonicIndex);
    }
  }

  /** @noinspection ALL */
  private void $$$loadButtonText$$$(AbstractButton component, String text) {
    StringBuffer result = new StringBuffer();
    boolean haveMnemonic = false;
    char mnemonic = '\0';
    int mnemonicIndex = -1;
    for (int i = 0; i < text.length(); i++) {
      if (text.charAt(i) == '&') {
        i++;
        if (i == text.length()) break;
        if (!haveMnemonic && text.charAt(i) != '&') {
          haveMnemonic = true;
          mnemonic = text.charAt(i);
          mnemonicIndex = result.length();
        }
      }
      result.append(text.charAt(i));
    }
    component.setText(result.toString());
    if (haveMnemonic) {
      component.setMnemonic(mnemonic);
      component.setDisplayedMnemonicIndex(mnemonicIndex);
    }
  }

  /** @noinspection ALL */
  public JComponent $$$getRootComponent$$$() { return myPanel; }

  @Override
  public @NotNull JComponent getPanel() {
    return this;
  }

  @Override
  public void resetDefault() {
    try {
      myUiEventsEnabled = false;
      myLabelFont.setEnabled(false);
      myCbBold.setSelected(false);
      myCbBold.setEnabled(false);
      myCbItalic.setSelected(false);
      myCbItalic.setEnabled(false);
      updateColorChooser(myCbForeground, myForegroundChooser, false, false, null);
      updateColorChooser(myCbBackground, myBackgroundChooser, false, false, null);
      updateColorChooser(myCbErrorStripe, myErrorStripeColorChooser, false, false, null);
      updateColorChooser(myCbEffects, myEffectsColorChooser, false, false, null);
      myEffectsCombo.setEnabled(false);
      myInheritanceLabel.setVisible(false);
      myInheritAttributesBox.setVisible(false);
    }
    finally {
      myUiEventsEnabled = true;
    }
  }

  private static void updateColorChooser(JCheckBox checkBox,
                                         ColorPanel colorPanel,
                                         boolean isEnabled,
                                         boolean isChecked,
                                         @Nullable Color color) {
    updateColorChooser(checkBox, colorPanel, isEnabled, isChecked, color, false);
  }

  private static void updateColorChooser(JCheckBox checkBox,
                                         ColorPanel colorPanel,
                                         boolean isEnabled,
                                         boolean isChecked,
                                         @Nullable Color color,
                                         boolean supportTransparency) {
    checkBox.setEnabled(isEnabled);
    checkBox.setSelected(isChecked);
    if (color != null) {
      colorPanel.setSelectedColor(color);
    }
    else {
      colorPanel.setSelectedColor(JBColor.WHITE);
    }
    colorPanel.setSupportTransparency(supportTransparency);
    colorPanel.setEnabled(isChecked);
  }

  @Override
  public void reset(@NotNull EditorSchemeAttributeDescriptor attrDescription) {
    try {
      myUiEventsEnabled = false;
      if (!(attrDescription instanceof ColorAndFontDescription description)) return;

      if (description.isFontEnabled()) {
        myLabelFont.setEnabled(description.isEditable());
        myCbBold.setEnabled(description.isEditable());
        myCbItalic.setEnabled(description.isEditable());
        int fontType = description.getFontType();
        myCbBold.setSelected(BitUtil.isSet(fontType, Font.BOLD));
        myCbItalic.setSelected(BitUtil.isSet(fontType, Font.ITALIC));
      }
      else {
        myLabelFont.setEnabled(false);
        myCbBold.setSelected(false);
        myCbBold.setEnabled(false);
        myCbItalic.setSelected(false);
        myCbItalic.setEnabled(false);
      }

      updateColorChooser(myCbForeground, myForegroundChooser, description.isForegroundEnabled(),
                         description.isForegroundChecked(), description.getForegroundColor(), description.isTransparencyEnabled());

      updateColorChooser(myCbBackground, myBackgroundChooser, description.isBackgroundEnabled(),
                         description.isBackgroundChecked(), description.getBackgroundColor(), description.isTransparencyEnabled());

      updateColorChooser(myCbErrorStripe, myErrorStripeColorChooser, description.isErrorStripeEnabled(),
                         description.isErrorStripeChecked(), description.getErrorStripeColor(), description.isTransparencyEnabled());

      EffectType effectType = description.getEffectType();
      updateColorChooser(myCbEffects, myEffectsColorChooser, description.isEffectsColorEnabled(),
                         description.isEffectsColorChecked(), description.getEffectColor(), description.isTransparencyEnabled());

      @NlsSafe String name = ContainerUtil.reverseMap(myEffectsMap).get(effectType);
      myEffectsCombo.getModel().setSelectedItem(name);
      myEffectsCombo
        .setEnabled((description.isEffectsColorEnabled() && description.isEffectsColorChecked()) && description.isEditable());
      setInheritanceInfo(description);
      myLabelFont.setEnabled(myCbBold.isEnabled() || myCbItalic.isEnabled());
    }
    finally {
      myUiEventsEnabled = true;
    }
  }


  private void setInheritanceInfo(ColorAndFontDescription description) {
    Pair<ColorAndFontDescriptorsProvider, ? extends AbstractKeyDescriptor> baseDescriptor = description.getFallbackKeyDescriptor();
    if (baseDescriptor != null) {
      String attrName = baseDescriptor.second.getDisplayName();
      String attrLabel = attrName.replaceAll(EditorSchemeAttributeDescriptorWithPath.getNameSeparator(), FontUtil.rightArrow(
        StartupUiUtil.getLabelFont()));
      ColorAndFontDescriptorsProvider settingsPage = baseDescriptor.first;
      String tooltipText;
      String labelText;
      HtmlChunk.Element div = HtmlChunk.div("text-align:right").attr("vertical-align", "top");
      if (settingsPage != null) {
        String pageName = settingsPage.getDisplayName();
        tooltipText = IdeBundle.message("tooltip.inherited.editor.color.scheme", pageName, attrLabel);
        labelText = div.children(HtmlChunk.link(pageName, attrLabel), HtmlChunk.br(), HtmlChunk.text("(" + pageName + ")")).toString();
      }
      else {
        tooltipText = attrLabel;
        labelText = div.children(HtmlChunk.text(attrLabel), HtmlChunk.br(), HtmlChunk.nbsp()).toString();
      }

      myInheritanceLabel.setVisible(true);
      myInheritanceLabel.setText(labelText);
      myInheritanceLabel.getCaret().setDot(0);
      myInheritanceLabel.setToolTipText(tooltipText);
      myInheritanceLabel.setEnabled(true);
      myInheritAttributesBox.setVisible(true);
      myInheritAttributesBox.setEnabled(description.isEditable());
      myInheritAttributesBox.setSelected(description.isInherited());
      setEditEnabled(!description.isInherited() && description.isEditable(), description);
    }
    else {
      myInheritanceLabel.setVisible(false);
      myInheritAttributesBox.setSelected(false);
      myInheritAttributesBox.setVisible(false);
      setEditEnabled(description.isEditable(), description);
    }
  }

  private void setEditEnabled(boolean isEditEnabled, ColorAndFontDescription description) {
    myCbBackground.setEnabled(isEditEnabled && description.isBackgroundEnabled());
    myCbForeground.setEnabled(isEditEnabled && description.isForegroundEnabled());
    myCbBold.setEnabled(isEditEnabled && description.isFontEnabled());
    myCbItalic.setEnabled(isEditEnabled && description.isFontEnabled());
    myCbEffects.setEnabled(isEditEnabled && description.isEffectsColorEnabled());
    myCbErrorStripe.setEnabled(isEditEnabled && description.isErrorStripeEnabled());
    myErrorStripeColorChooser.setEditable(isEditEnabled);
    myEffectsColorChooser.setEditable(isEditEnabled);
    myForegroundChooser.setEditable(isEditEnabled);
    myBackgroundChooser.setEditable(isEditEnabled);
  }

  @Override
  public void apply(@NotNull EditorSchemeAttributeDescriptor attrDescription, EditorColorsScheme scheme) {
    if (!(attrDescription instanceof ColorAndFontDescription description)) return;

    description.setInherited(myInheritAttributesBox.isSelected());
    if (description.isInherited()) {
      TextAttributes baseAttributes = description.getBaseAttributes();
      if (baseAttributes != null) {
        description.setFontType(baseAttributes.getFontType());
        description.setForegroundChecked(baseAttributes.getForegroundColor() != null);
        description.setForegroundColor(baseAttributes.getForegroundColor());
        description.setBackgroundChecked(baseAttributes.getBackgroundColor() != null);
        description.setBackgroundColor(baseAttributes.getBackgroundColor());
        description.setErrorStripeChecked(baseAttributes.getErrorStripeColor() != null);
        description.setErrorStripeColor(baseAttributes.getErrorStripeColor());
        description.setEffectColor(baseAttributes.getEffectColor());
        description.setEffectType(baseAttributes.getEffectType());
        description.setEffectsColorChecked(baseAttributes.getEffectColor() != null);
      }
      else {
        description.setInherited(false);
      }
      reset(description);
    }
    else {
      setInheritanceInfo(description);
      int fontType = Font.PLAIN;
      if (myCbBold.isSelected()) fontType |= Font.BOLD;
      if (myCbItalic.isSelected()) fontType |= Font.ITALIC;
      description.setFontType(fontType);
      description.setForegroundChecked(myCbForeground.isSelected());
      description.setForegroundColor(myForegroundChooser.getSelectedColor());
      description.setBackgroundChecked(myCbBackground.isSelected());
      description.setBackgroundColor(myBackgroundChooser.getSelectedColor());
      description.setErrorStripeChecked(myCbErrorStripe.isSelected());
      description.setErrorStripeColor(myErrorStripeColorChooser.getSelectedColor());
      description.setEffectsColorChecked(myCbEffects.isSelected());
      description.setEffectColor(myEffectsColorChooser.getSelectedColor());

      if (myEffectsCombo.isEnabled()) {
        String effectType = (String)myEffectsCombo.getModel().getSelectedItem();
        description.setEffectType(myEffectsMap.get(effectType));
      }
    }
    description.apply(scheme);
  }

  @Override
  public void addListener(@NotNull Listener listener) {
    myDispatcher.addListener(listener);
  }
}
