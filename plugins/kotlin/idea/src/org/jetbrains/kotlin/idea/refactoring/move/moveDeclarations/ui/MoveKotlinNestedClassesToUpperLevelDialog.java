// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

package org.jetbrains.kotlin.idea.refactoring.move.moveDeclarations.ui;

import com.intellij.openapi.options.ConfigurationException;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiDirectory;
import com.intellij.psi.PsiElement;
import com.intellij.refactoring.HelpID;
import com.intellij.refactoring.PackageWrapper;
import com.intellij.refactoring.RefactoringBundle;
import com.intellij.refactoring.move.MoveDialogBase;
import com.intellij.refactoring.ui.NameSuggestionsField;
import com.intellij.refactoring.ui.PackageNameReferenceEditorCombo;
import com.intellij.refactoring.util.CommonMoveClassesOrPackagesUtil;
import com.intellij.ui.EditorTextField;
import com.intellij.ui.NonFocusableCheckBox;
import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;
import com.intellij.uiDesigner.core.Spacer;
import com.intellij.util.ArrayUtil;
import kotlin.jvm.functions.Function1;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.kotlin.descriptors.ClassDescriptor;
import org.jetbrains.kotlin.idea.base.codeInsight.KotlinNameSuggestionProvider;
import org.jetbrains.kotlin.idea.base.fe10.codeInsight.newDeclaration.Fe10KotlinNameSuggester;
import org.jetbrains.kotlin.idea.base.fe10.codeInsight.newDeclaration.Fe10KotlinNewDeclarationNameValidator;
import org.jetbrains.kotlin.idea.base.resources.KotlinBundle;
import org.jetbrains.kotlin.idea.caches.resolve.ResolutionUtils;
import org.jetbrains.kotlin.idea.core.CollectingNameValidator;
import org.jetbrains.kotlin.idea.refactoring.KotlinRefactoringSettings;
import org.jetbrains.kotlin.idea.refactoring.move.MoveUtilKt;
import org.jetbrains.kotlin.name.FqName;
import org.jetbrains.kotlin.psi.KtClass;
import org.jetbrains.kotlin.psi.KtClassBody;
import org.jetbrains.kotlin.psi.KtClassOrObject;
import org.jetbrains.kotlin.resolve.lazy.BodyResolveMode;
import org.jetbrains.kotlin.types.KotlinType;

import javax.swing.AbstractButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.Insets;
import java.lang.reflect.Method;
import java.util.BitSet;
import java.util.Collections;
import java.util.List;
import java.util.ResourceBundle;

public class MoveKotlinNestedClassesToUpperLevelDialog extends MoveDialogBase {
  private static final @NonNls String RECENTS_KEY = MoveKotlinNestedClassesToUpperLevelDialog.class.getName() + ".RECENTS_KEY";

  private final Project project;
  private final KtClassOrObject innerClass;
  private final ClassDescriptor innerClassDescriptor;

  private final PsiElement targetContainer;
  private final EditorTextField classNameField;
  private final NameSuggestionsField parameterField;
  private final JCheckBox passOuterClassCheckBox;
  private final JPanel panel;
  private final JCheckBox searchInCommentsCheckBox;
  private final JCheckBox searchForTextOccurrencesCheckBox;
  private final PackageNameReferenceEditorCombo packageNameField;
  private final JLabel packageNameLabel;
  private final JLabel classNameLabel;
  private final JLabel parameterNameLabel;
  private final JPanel openInEditorPanel;

  public MoveKotlinNestedClassesToUpperLevelDialog(
    @NotNull Project project,
    @NotNull KtClassOrObject innerClass,
    @NotNull PsiElement targetContainer
  ) {
    super(project, true);
    this.project = project;
    this.innerClass = innerClass;
    this.targetContainer = targetContainer;
    {
      parameterField = new NameSuggestionsField(project);
      packageNameField = new PackageNameReferenceEditorCombo("", project, RECENTS_KEY,
                                                             RefactoringBundle.message("choose.destination.package"));
    }
    {
      // GUI initializer generated by IntelliJ IDEA GUI Designer
      // >>> IMPORTANT!! <<<
      // DO NOT EDIT OR ADD ANY CODE HERE!
      panel = new JPanel();
      panel.setLayout(new GridLayoutManager(10, 2, new Insets(0, 0, 0, 0), -1, -1));
      classNameLabel = new JLabel();
      this.$$$loadLabelText$$$(classNameLabel, this.$$$getMessageFromBundle$$$("messages/KotlinBundle", "class.name.prompt"));
      panel.add(classNameLabel,
                new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                    GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      final Spacer spacer1 = new Spacer();
      panel.add(spacer1, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
                                             GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));
      final Spacer spacer2 = new Spacer();
      panel.add(spacer2, new GridConstraints(9, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_VERTICAL, 1,
                                             GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
      classNameField = new EditorTextField();
      panel.add(classNameField, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL,
                                                    GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                                                    GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null,
                                                    null, 0, false));
      passOuterClassCheckBox = new NonFocusableCheckBox();
      this.$$$loadButtonText$$$(passOuterClassCheckBox,
                                this.$$$getMessageFromBundle$$$("messages/KotlinBundle", "pass.outer.class.instance.as.parameter"));
      panel.add(passOuterClassCheckBox, new GridConstraints(4, 0, 1, 2, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE,
                                                            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                                                            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                                                            null, null, null, 0, false));
      parameterNameLabel = new JLabel();
      this.$$$loadLabelText$$$(parameterNameLabel, this.$$$getMessageFromBundle$$$("messages/KotlinBundle", "parameter.name.prompt"));
      panel.add(parameterNameLabel,
                new GridConstraints(5, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                    GridConstraints.SIZEPOLICY_FIXED, null, null, null, 1, false));
      panel.add(parameterField, new GridConstraints(6, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,
                                                    GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                                                    GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null,
                                                    null, 1, false));
      final JPanel panel1 = new JPanel();
      panel1.setLayout(new FlowLayout(FlowLayout.LEFT, 5, 5));
      panel.add(panel1, new GridConstraints(7, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,
                                            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                                            GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null,
                                            0, false));
      searchInCommentsCheckBox = new NonFocusableCheckBox();
      this.$$$loadButtonText$$$(searchInCommentsCheckBox,
                                this.$$$getMessageFromBundle$$$("messages/KotlinBundle", "search.in.comments.and.strings"));
      panel1.add(searchInCommentsCheckBox);
      searchForTextOccurrencesCheckBox = new NonFocusableCheckBox();
      this.$$$loadButtonText$$$(searchForTextOccurrencesCheckBox,
                                this.$$$getMessageFromBundle$$$("messages/KotlinBundle", "search.for.text.occurrences"));
      panel1.add(searchForTextOccurrencesCheckBox);
      packageNameLabel = new JLabel();
      this.$$$loadLabelText$$$(packageNameLabel, this.$$$getMessageFromBundle$$$("messages/KotlinBundle", "label.text.package.name"));
      panel.add(packageNameLabel,
                new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,
                                    GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
      panel.add(packageNameField, new GridConstraints(3, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,
                                                      GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                                                      GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null,
                                                      null, null, 0, false));
      openInEditorPanel = new JPanel();
      openInEditorPanel.setLayout(new BorderLayout(0, 0));
      panel.add(openInEditorPanel, new GridConstraints(8, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,
                                                       GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,
                                                       GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null,
                                                       null, null, 0, false));
    }
    this.innerClassDescriptor = (ClassDescriptor)ResolutionUtils.unsafeResolveToDescriptor(innerClass, BodyResolveMode.FULL);
    setTitle(KotlinBundle.message("title.move.nested.classes.to.upper.level"));
    init();
    packageNameLabel.setLabelFor(packageNameField.getChildComponent());
    classNameLabel.setLabelFor(classNameField);
    parameterNameLabel.setLabelFor(parameterField);
    openInEditorPanel.add(initOpenInEditorCb(), BorderLayout.EAST);
  }

  private static Method $$$cachedGetBundleMethod$$$ = null;

  /** @noinspection ALL */
  private String $$$getMessageFromBundle$$$(String path, String key) {
    ResourceBundle bundle;
    try {
      Class<?> thisClass = this.getClass();
      if ($$$cachedGetBundleMethod$$$ == null) {
        Class<?> dynamicBundleClass = thisClass.getClassLoader().loadClass("com.intellij.DynamicBundle");
        $$$cachedGetBundleMethod$$$ = dynamicBundleClass.getMethod("getBundle", String.class, Class.class);
      }
      bundle = (ResourceBundle)$$$cachedGetBundleMethod$$$.invoke(null, path, thisClass);
    }
    catch (Exception e) {
      bundle = ResourceBundle.getBundle(path);
    }
    return bundle.getString(key);
  }

  /** @noinspection ALL */
  private void $$$loadLabelText$$$(JLabel component, String text) {
    StringBuffer result = new StringBuffer();
    boolean haveMnemonic = false;
    char mnemonic = '\0';
    int mnemonicIndex = -1;
    for (int i = 0; i < text.length(); i++) {
      if (text.charAt(i) == '&') {
        i++;
        if (i == text.length()) break;
        if (!haveMnemonic && text.charAt(i) != '&') {
          haveMnemonic = true;
          mnemonic = text.charAt(i);
          mnemonicIndex = result.length();
        }
      }
      result.append(text.charAt(i));
    }
    component.setText(result.toString());
    if (haveMnemonic) {
      component.setDisplayedMnemonic(mnemonic);
      component.setDisplayedMnemonicIndex(mnemonicIndex);
    }
  }

  /** @noinspection ALL */
  private void $$$loadButtonText$$$(AbstractButton component, String text) {
    StringBuffer result = new StringBuffer();
    boolean haveMnemonic = false;
    char mnemonic = '\0';
    int mnemonicIndex = -1;
    for (int i = 0; i < text.length(); i++) {
      if (text.charAt(i) == '&') {
        i++;
        if (i == text.length()) break;
        if (!haveMnemonic && text.charAt(i) != '&') {
          haveMnemonic = true;
          mnemonic = text.charAt(i);
          mnemonicIndex = result.length();
        }
      }
      result.append(text.charAt(i));
    }
    component.setText(result.toString());
    if (haveMnemonic) {
      component.setMnemonic(mnemonic);
      component.setDisplayedMnemonicIndex(mnemonicIndex);
    }
  }

  /** @noinspection ALL */
  public JComponent $$$getRootComponent$$$() { return panel; }

  @Override
  protected String getMovePropertySuffix() {
    return KotlinBundle.message("text.nested.classes.to.upper.level");
  }

  @Override
  protected String getHelpId() {
    return HelpID.MOVE_INNER_UPPER;
  }

  @Override
  protected String getCbTitle() {
    return KotlinBundle.message("checkbox.text.open.moved.files.in.editor");
  }

  public String getClassName() {
    return classNameField.getText().trim();
  }

  public @Nullable String getParameterName() {
    return parameterField != null ? parameterField.getEnteredName() : null;
  }

  private boolean isThisNeeded() {
    return innerClass instanceof KtClass && MoveUtilKt.traverseOuterInstanceReferences(innerClass, true);
  }

  private @Nullable FqName getTargetPackageFqName() {
    return MoveUtilKt.getTargetPackageFqName(targetContainer);
  }

  private @NotNull KotlinType getOuterInstanceType() {
    return ((ClassDescriptor)innerClassDescriptor.getContainingDeclaration()).getDefaultType();
  }

  private BitSet initializedCheckBoxesState;

  private BitSet getCheckboxesState(boolean applyDefaults) {

    BitSet state = new BitSet(3);

    state.set(0, !applyDefaults && searchInCommentsCheckBox.isSelected()); //searchInCommentsCheckBox default is false
    state.set(1, !applyDefaults && searchForTextOccurrencesCheckBox.isSelected()); //searchForTextOccurrencesCheckBox default is false
    state.set(2, passOuterClassCheckBox.isSelected());

    return state;
  }


  @Override
  protected void init() {
    classNameField.setText(innerClass.getName());
    classNameField.selectAll();

    if (innerClass instanceof KtClass && ((KtClass)innerClass).isInner()) {
      passOuterClassCheckBox.setSelected(true);
      passOuterClassCheckBox.addItemListener(e -> parameterField.setEnabled(passOuterClassCheckBox.isSelected()));
    }
    else {
      passOuterClassCheckBox.setSelected(false);
      passOuterClassCheckBox.setEnabled(false);
      parameterField.setEnabled(false);
    }

    if (passOuterClassCheckBox.isEnabled()) {
      boolean thisNeeded = isThisNeeded();
      passOuterClassCheckBox.setSelected(thisNeeded);
      parameterField.setEnabled(thisNeeded);
    }

    passOuterClassCheckBox.addItemListener(e -> {
      boolean selected = passOuterClassCheckBox.isSelected();
      parameterField.getComponent().setEnabled(selected);
    });

    if (!(targetContainer instanceof PsiDirectory)) {
      packageNameField.setVisible(false);
      packageNameLabel.setVisible(false);
    }

    if (innerClass instanceof KtClass && ((KtClass)innerClass).isInner()) {
      KtClassBody innerClassBody = innerClass.getBody();
      Function1<String, Boolean> validator =
        innerClassBody != null
        ? new Fe10KotlinNewDeclarationNameValidator(innerClassBody, (PsiElement)null,
                                                    KotlinNameSuggestionProvider.ValidatorTarget.PARAMETER,
                                                    Collections.emptyList())
        : new CollectingNameValidator();
      List<String> suggestions = Fe10KotlinNameSuggester.INSTANCE.suggestNamesByType(getOuterInstanceType(), validator, "outer");
      parameterField.setSuggestions(ArrayUtil.toStringArray(suggestions));
    }
    else {
      parameterField.getComponent().setEnabled(false);
    }

    FqName packageFqName = getTargetPackageFqName();
    if (packageFqName != null) {
      packageNameField.prependItem(packageFqName.asString());
    }

    KotlinRefactoringSettings settings = KotlinRefactoringSettings.getInstance();
    searchForTextOccurrencesCheckBox.setSelected(settings.MOVE_TO_UPPER_LEVEL_SEARCH_FOR_TEXT);
    searchInCommentsCheckBox.setSelected(settings.MOVE_TO_UPPER_LEVEL_SEARCH_IN_COMMENTS);

    super.init();

    initializedCheckBoxesState = getCheckboxesState(true);
  }

  @Override
  public JComponent getPreferredFocusedComponent() {
    return classNameField;
  }

  @Override
  protected String getDimensionServiceKey() {
    return "#com.intellij.refactoring.move.moveInner.MoveInnerDialog";
  }

  @Override
  protected JComponent createNorthPanel() {
    return panel;
  }

  @Override
  protected JComponent createCenterPanel() {
    return null;
  }


  private static class MoveKotlinNestedClassesToUpperLevelModelWithUIChooser extends MoveKotlinNestedClassesToUpperLevelModel {
    public MoveKotlinNestedClassesToUpperLevelModelWithUIChooser(
      @NotNull Project project,
      @NotNull KtClassOrObject innerClass,
      @NotNull PsiElement target,
      @Nullable String parameter,
      @NotNull String className,
      boolean passOuterClass,
      boolean searchInComments,
      boolean isSearchInNonJavaFiles,
      @NotNull String packageName,
      boolean isOpenInEditor
    ) {
      super(project, innerClass, target, parameter, className, passOuterClass, searchInComments, isSearchInNonJavaFiles, packageName,
            isOpenInEditor);
    }

    @Override
    protected @Nullable VirtualFile chooseSourceRoot(
      @NotNull PackageWrapper newPackage,
      @NotNull List<? extends VirtualFile> contentSourceRoots,
      @Nullable PsiDirectory initialDir
    ) {
      return CommonMoveClassesOrPackagesUtil.chooseSourceRoot(newPackage, contentSourceRoots, initialDir);
    }
  }

  private Model getModel() {
    return new MoveKotlinNestedClassesToUpperLevelModelWithUIChooser(
      project,
      innerClass,
      targetContainer,
      getParameterName(),
      getClassName(),
      passOuterClassCheckBox.isSelected(),
      searchInCommentsCheckBox.isSelected(),
      searchForTextOccurrencesCheckBox.isSelected(),
      packageNameField.getText(),
      isOpenInEditor()
    );
  }

  @Override
  protected void doAction() {

    ModelResultWithFUSData modelResult;
    try {
      modelResult = getModel().computeModelResult();
    }
    catch (ConfigurationException e) {
      setErrorHtml(e.getMessageHtml());
      return;
    }

    KotlinRefactoringSettings settings = KotlinRefactoringSettings.getInstance();
    settings.MOVE_TO_UPPER_LEVEL_SEARCH_FOR_TEXT = searchForTextOccurrencesCheckBox.isSelected();
    settings.MOVE_TO_UPPER_LEVEL_SEARCH_IN_COMMENTS = searchInCommentsCheckBox.isSelected();

    saveOpenInEditorOption();

    MoveUtilKt.logFusForMoveRefactoring(
      modelResult.getElementsCount(),
      modelResult.getEntityToMove(),
      modelResult.getDestination(),
      getCheckboxesState(false).equals(initializedCheckBoxesState),
      () -> invokeRefactoring(modelResult.getProcessor())
    );
  }
}