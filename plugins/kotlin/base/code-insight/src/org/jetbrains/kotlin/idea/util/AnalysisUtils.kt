// Copyright 2000-2026 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.kotlin.idea.util

import com.intellij.psi.impl.compiled.ClsParameterImpl
import org.jetbrains.kotlin.analysis.api.KaExperimentalApi
import org.jetbrains.kotlin.analysis.api.KaSession
import org.jetbrains.kotlin.analysis.api.renderer.declarations.KaDeclarationRenderer
import org.jetbrains.kotlin.analysis.api.renderer.declarations.renderers.KaDeclarationNameRenderer
import org.jetbrains.kotlin.analysis.api.signatures.KaVariableSignature
import org.jetbrains.kotlin.analysis.api.symbols.KaSymbolModality
import org.jetbrains.kotlin.analysis.api.symbols.KaValueParameterSymbol
import org.jetbrains.kotlin.analysis.api.symbols.markers.KaNamedSymbol
import org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.psi.KtProperty

fun KaSession.isBackingFieldRequired(property: KtProperty): Boolean {
    val getter = property.getter
    val resolvedGetter = getter?.symbol
    val setter = property.setter
    val resolvedSetter = setter?.symbol

    if (getter == null) return true
    if (property.isVar && setter == null) return true
    if (resolvedSetter != null && !setter.hasBody() && resolvedSetter.modality != KaSymbolModality.ABSTRACT) return true
    if (!getter.hasBody() && resolvedGetter?.modality != KaSymbolModality.ABSTRACT) return true

    return false
}

/**
 * A real name for the parameter.
 *
 * Not all parameters might have a real (non-synthesized) name,
 * so in some cases the IDE needs to behave differently if no meaningful name is available.
 *
 * Also, in some cases the name might be determined by the IJ platform,
 * so this property might return a real name even for a value parameter with synthesized name.
 *
 * @see KaVariableSignature.realName
 * @see KaValueParameterSymbol.hasSynthesizedName
 */
@OptIn(KaExperimentalApi::class)
context(_: KaSession)
val KaValueParameterSymbol.realName: Name?
    get() {
        if (!hasSynthesizedName) {
            return name
        }

        return realJavaName
    }

/**
 * Creates a renderer that uses names from attached sources for value parameters based on cls java parameter names and delegates to the initial renderer otherwise
 *
 * @see KaVariableSignature.realName
 * @see KaValueParameterSymbol.hasSynthesizedName
 */
@OptIn(KaExperimentalApi::class)
fun createRealNameRenderer(renderer: KaDeclarationNameRenderer): KaDeclarationNameRenderer = object : KaDeclarationNameRenderer {
    override fun renderName(
        analysisSession: KaSession,
        name: Name,
        symbol: KaNamedSymbol?,
        declarationRenderer: KaDeclarationRenderer,
        printer: PrettyPrinter
    ) {
        if (symbol is KaValueParameterSymbol && symbol.hasSynthesizedName) {
            printer.append((with(analysisSession) { symbol.realName } ?: name).asString())
        } else {
            renderer.renderName(analysisSession, name, symbol, declarationRenderer, printer)
        }
    }
}

/**
 * A real name for the parameter represented by the given signature.
 *
 * The only difference from [KaValueParameterSymbol.realName] is that it uses the signature's
 * [KaVariableSignature.name] instead of the symbol's name that allows having a proper name in more cases.
 *
 * @see KaValueParameterSymbol.realName
 */
@OptIn(KaExperimentalApi::class)
context(_: KaSession)
val KaVariableSignature<KaValueParameterSymbol>.realName: Name?
    get() = when {
        // KaVariableSignature#name is used since it might have more correct name
        !symbol.hasSynthesizedName -> name
        else -> symbol.realJavaName
    }

private val KaValueParameterSymbol.realJavaName: Name?
    get() {
        val javaPsi = psi as? ClsParameterImpl
        return if (javaPsi?.isAutoGeneratedName != false) {
            null
        } else {
            Name.identifier(javaPsi.name)
        }
    }
