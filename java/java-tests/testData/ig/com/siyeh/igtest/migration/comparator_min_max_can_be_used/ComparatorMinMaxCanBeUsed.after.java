package com.siyeh.igtest.migration.comparator_min_max_can_be_used;

import java.util.Comparator;

class ComparatorMinMaxCanBeUsed {
  void testGreaterThan(Comparator<String> comp, String a, String b) {
    String r1 = comp.max(a, b);
    String r2 = comp.min(a, b);
  }

  void testLessThan(Comparator<String> comp, String a, String b) {
    String r1 = comp.min(a, b);
    String r2 = comp.max(a, b);
  }

  void testGreaterThanOrEqual(Comparator<String> comp, String a, String b) {
    String r1 = comp.max(a, b);
    String r2 = comp.min(a, b);
  }

  void testLessThanOrEqual(Comparator<String> comp, String a, String b) {
    String r1 = comp.min(a, b);
    String r2 = comp.max(a, b);
  }

  void testReversedComparison(Comparator<String> comp, String a, String b) {
    // 0 < compare(a, b) is equivalent to compare(a, b) > 0
    String r1 = comp.max(a, b);
    // 0 >= compare(a, b) is equivalent to compare(a, b) <= 0
    String r2 = comp.max(a, b);
  }

  void testParenthesized(Comparator<String> comp, String a, String b) {
    String r1 = comp.max(a, b);
    String r2 = comp.min(a, b);
  }

  // If-statement patterns
  String testIfReturnGreaterThan(Comparator<String> comp, String a, String b) {
      return comp.max(a, b);
  }

  String testIfReturnLessThan(Comparator<String> comp, String a, String b) {
      return comp.min(a, b);
  }

  String testIfReturnReversedBranches(Comparator<String> comp, String a, String b) {
      return comp.min(a, b);
  }

  String testIfReturnWithBlocks(Comparator<String> comp, String a, String b) {
      return comp.max(a, b);
  }

  String testIfImplicitReturn(Comparator<String> comp, String a, String b) {
      return comp.max(a, b);
  }

  void testIfAssignment(Comparator<String> comp, String a, String b) {
    String r = comp.max(a, b);
      System.out.println(r);
  }

  void testIfOverwrittenDeclaration(Comparator<String> comp, String a, String b) {
    String r = comp.max(a, b);
      System.out.println(r);
  }

  void testIfGreaterOrEqual(Comparator<String> comp, String a, String b) {
    String r = comp.max(a, b);
      System.out.println(r);
  }

  void testIfReversedComparison(Comparator<String> comp, String a, String b) {
    String r = comp.max(a, b);
      System.out.println(r);
  }

  void testIfNoWarning(Comparator<String> comp, String a, String b) {
    // Non-matching branches
    String r;
    if (comp.compare(a, b) > 0) r = a; else r = "default";
    // Comparison to non-zero
    if (comp.compare(a, b) > 1) r = a; else r = b;
    // Equality comparison
    if (comp.compare(a, b) == 0) r = a; else r = b;
    System.out.println(r);
  }

  void testNoWarning(Comparator<String> comp, String a, String b) {
    // Side effects in compare arguments
    String r1 = comp.max(a.trim(), b.trim());
    // Non-matching branches
    String r2 = comp.compare(a, b) > 0 ? a : "default";
    // Comparison to non-zero
    String r3 = comp.compare(a, b) > 1 ? a : b;
    // Equality comparison
    String r4 = comp.compare(a, b) == 0 ? a : b;
    // Not a Comparator.compare call
    int cmp = comp.compare(a, b);
    String r5 = cmp > 0 ? a : b;
    // Branches swapped with unrelated expressions
    String r6 = comp.compare(a, b) > 0 ? b : b;
  }
}
