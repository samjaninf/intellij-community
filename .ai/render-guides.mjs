// Copyright 2000-2026 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
import {access, copyFile, mkdir, readdir, readFile, rm, writeFile} from "node:fs/promises"
import {dirname, join, relative, resolve, sep} from "node:path"
import process from "node:process"
import {fileURLToPath} from "node:url"

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const repoRoot = resolve(__dirname, "..", "..");
const templatesDir = join(repoRoot, "community", ".ai");
const partialsDir = join(templatesDir, "partials");
const sharedPartialsDir = join(repoRoot, ".ai", "partials");

const generatedGuideHeader =
  "<!-- Generated by community/.ai/render-guides.mjs; edit community/.ai/* -->\n\n";
const generatedBeadsHeader =
  "<!-- Generated by community/.ai/render-guides.mjs; edit community/build/mcp-servers/task/beads-semantics.md -->\n\n";

const validEditions = new Set(["ULTIMATE", "COMMUNITY"]);

/**
 * @typedef {Object} OutputTarget
 * @property {string} name
 * @property {string} tool
 * @property {string} [template]
 * @property {string} [templatePath]
 * @property {string} output
 * @property {string} [runContext]
 * @property {string} [forbiddenToolsSuffix]
 * @property {boolean} [usesCompilationRule]
 * @property {string} [generatedHeader]
 * @property {string} [generatedHeaderPosition]
 * @property {string} [edition]
 * @property {string} [onlyWhenEdition]
 */

/** @type {OutputTarget[]} */
const outputs = [
  {
    name: "AGENTS.md",
    tool: "CODEX",
    template: "guide.md",
    output: "AGENTS.md",
    runContext: "via terminal command tool (not JetBrains MCP terminal)",
    forbiddenToolsSuffix: "",
    usesCompilationRule: true,
    generatedHeader: generatedGuideHeader,
    generatedHeaderPosition: "after-frontmatter",
  },
  {
    name: "AGENTS.md (community)",
    tool: "CODEX",
    template: "guide.md",
    output: "community/AGENTS.md",
    runContext: "via terminal command tool (not JetBrains MCP terminal)",
    forbiddenToolsSuffix: "",
    usesCompilationRule: true,
    generatedHeader: generatedGuideHeader,
    generatedHeaderPosition: "after-frontmatter",
    edition: "COMMUNITY",
    onlyWhenEdition: "ULTIMATE",
  },
  {
    name: "CLAUDE.md (ultimate)",
    tool: "CLAUDE",
    template: "guide.md",
    output: "CLAUDE.md",
    runContext: "from the shell/CLI",
    forbiddenToolsSuffix: "",
    usesCompilationRule: true,
    generatedHeader: generatedGuideHeader,
    generatedHeaderPosition: "after-frontmatter",
    edition: "ULTIMATE",
    onlyWhenEdition: "ULTIMATE",
  },
  {
    name: "Beads rules (CLAUDE)",
    tool: "CLAUDE",
    templatePath: "community/build/mcp-servers/task/beads-semantics.md",
    output: ".claude/rules/beads.md",
    forbiddenToolsSuffix: "",
    usesCompilationRule: false,
    generatedHeader: generatedBeadsHeader,
  },
];

function normalize(text) {
  const normalized = text.replace(/\r\n/g, "\n");
  const collapsed = normalized.replace(/\n{3,}/g, "\n\n");
  return collapsed.trimEnd() + "\n";
}

function renderCompilationRule(template, runContext) {
  const rendered = template.replace("{{RUN_CONTEXT}}", runContext).trim();
  if (rendered.includes("{{RUN_CONTEXT}}")) {
    throw new Error("Compilation template still contains {{RUN_CONTEXT}} placeholder.");
  }
  return rendered;
}

function replaceAll(text, token, value) {
  return text.split(token).join(value);
}

function splitLinkTarget(target) {
  const match = target.match(/^([^?#]+)([?#].*)?$/);
  if (!match) {
    return { path: target, suffix: "" };
  }
  return { path: match[1], suffix: match[2] ?? "" };
}

function isRelativeLinkTarget(target) {
  if (target.startsWith("#")) {
    return false;
  }
  if (target.startsWith("/")) {
    return false;
  }
  if (/^[a-z][a-z0-9+.-]*:/i.test(target)) {
    return false;
  }
  return true;
}

function ensureDotSlash(value) {
  if (value === "" || value === ".") {
    return "./";
  }
  if (value.startsWith("./") || value.startsWith("../") || value.startsWith("/")) {
    return value;
  }
  return `./${value}`;
}

function toPosixPath(value) {
  return value.split(sep).join("/");
}

function rewriteLinkTarget(rawTarget, sourcePath, outputPath) {
  const { path, suffix } = splitLinkTarget(rawTarget);
  if (!path || !isRelativeLinkTarget(path)) {
    return rawTarget;
  }
  const absolutePath = resolve(dirname(sourcePath), path);
  const outputDir = dirname(outputPath);
  let relativePath = relative(outputDir, absolutePath);
  relativePath = ensureDotSlash(relativePath);
  return toPosixPath(relativePath) + suffix;
}

const inlineLinkPattern = /(!?\[[^\]]*])\(([^)\s]+)(\s+[^)]+)?\)/g;

function rewriteInlineLinks(text, sourcePath, outputPath) {
  return text.replace(inlineLinkPattern, (match, label, target, title = "") => {
    const rewrittenTarget = rewriteLinkTarget(target, sourcePath, outputPath);
    return `${label}(${rewrittenTarget}${title})`;
  });
}

const referenceLinkPattern = /^(\s*\[[^\]]+]:\s*)(\S+)(.*)$/gm;

function rewriteReferenceLinks(text, sourcePath, outputPath) {
  return text.replace(referenceLinkPattern, (match, prefix, target, suffix) => {
    const rewrittenTarget = rewriteLinkTarget(target, sourcePath, outputPath);
    return `${prefix}${rewrittenTarget}${suffix}`;
  });
}

function rewriteMarkdownLinks(text, sourcePath, outputPath) {
  const withInlineLinks = rewriteInlineLinks(text, sourcePath, outputPath);
  return rewriteReferenceLinks(withInlineLinks, sourcePath, outputPath);
}

const partialPattern = /\{\{PARTIAL:([^}]+)[}][}]/g;
const partialPatternCheck = /\{\{PARTIAL:[^}]+[}][}]/;

async function loadPartialsFromDir(dir) {
  let entries;
  try {
    entries = await readdir(dir, {withFileTypes: true});
  } catch (error) {
    if (error && error.code === "ENOENT") {
      return new Map();
    }
    throw error;
  }
  const partials = new Map();
  for (const entry of entries) {
    if (!entry.isFile() || !entry.name.endsWith(".md")) {
      continue;
    }
    const name = entry.name.replace(/\.md$/, "");
    const path = join(dir, entry.name);
    const content = await readFile(path, "utf8");
    partials.set(name, {content: content.trimEnd(), path});
  }
  return partials;
}

async function loadPartials() {
  const partials = new Map();
  const sources = [partialsDir, sharedPartialsDir];
  for (const source of sources) {
    const next = await loadPartialsFromDir(source);
    for (const [name, partial] of next.entries()) {
      partials.set(name, partial);
    }
  }
  return partials;
}

function applyPartials(text, partials) {
  return text.replace(partialPattern, (match, name) => {
    const partial = partials.get(name);
    if (partial === undefined) {
      throw new Error(`Unknown partial: ${name}`);
    }
    return partial;
  });
}

const templateBlockPattern = /<!-- TEMPLATE:COMMENT -->[\s\S]*?<!-- \/TEMPLATE:COMMENT -->\n?/g;

function stripTemplateBlocks(text) {
  return text.replace(templateBlockPattern, "");
}

const toolBlockPattern = /<!--\s*IF_TOOL:([A-Z0-9_-]+)\s*-->([\s\S]*?)<!--\s*\/IF_TOOL:\1\s*-->/gi;

function applyToolBlocks(text, tool) {
  const normalizedTool = (tool ?? "").toUpperCase();
  return text.replace(toolBlockPattern, (match, blockTool, content) => {
    if (blockTool.toUpperCase() === normalizedTool) {
      return content;
    }
    return "";
  });
}

const editionBlockPattern = /<!--\s*IF_EDITION:([A-Z0-9_-]+)\s*-->([\s\S]*?)<!--\s*\/IF_EDITION:\1\s*-->/gi;
const unresolvedToolDirectivePattern = /<!--\s*\/?IF_TOOL:[^>]+-->/i;
const unresolvedEditionDirectivePattern = /<!--\s*\/?IF_EDITION:[^>]+-->/i;
const unresolvedTemplateCommentPattern = /<!--\s*\/?TEMPLATE:COMMENT\s*-->/i;

function applyEditionBlocks(text, edition) {
  const normalizedEdition = (edition ?? "").toUpperCase();
  return text.replace(editionBlockPattern, (match, blockEdition, content) => {
    if (blockEdition.toUpperCase() === normalizedEdition) {
      return content;
    }
    return "";
  });
}

function assertNoUnresolvedTemplateDirectives(text, targetName) {
  if (unresolvedToolDirectivePattern.test(text)) {
    throw new Error(`${targetName} rendered output still has unresolved IF_TOOL directives.`);
  }
  if (unresolvedEditionDirectivePattern.test(text)) {
    throw new Error(`${targetName} rendered output still has unresolved IF_EDITION directives.`);
  }
  if (unresolvedTemplateCommentPattern.test(text)) {
    throw new Error(`${targetName} rendered output still has unresolved TEMPLATE:COMMENT directives.`);
  }
}

function normalizeEdition(value) {
  const normalized = value.trim().toUpperCase();
  if (!validEditions.has(normalized)) {
    throw new Error(`Unknown edition "${value}". Use community or ultimate.`);
  }
  return normalized;
}

async function detectEdition() {
  const envEdition = process.env["AI_GUIDE_EDITION"] ?? process.env["RENDER_EDITION"];
  if (envEdition) {
    return normalizeEdition(envEdition);
  }
  try {
    await access(join(repoRoot, ".ultimate.root.marker"));
    return "ULTIMATE";
  } catch {
    return "COMMUNITY";
  }
}

const compilationTemplatePath = join(templatesDir, "compilation.md");
const mcpConfigPath = join(repoRoot, ".mcp.json");
const opencodeConfigPath = join(repoRoot, "opencode.json");
const codexSkillsDir = join(repoRoot, ".codex", "skills");
const opencodeSkillsDir = join(repoRoot, ".opencode", "skill");
const communitySkillsSourceDir = join(repoRoot, "community", ".agents", "skills");
const agentsSkillsDir = join(repoRoot, ".agents", "skills");
const claudeSkillsDir = join(repoRoot, ".claude", "skills");
const communityClaudeSkillsDir = join(repoRoot, "community", ".claude", "skills");
const generatedSkillMarker = "<!-- Generated by community/.ai/render-guides.mjs";
const opencodeJetBrainsMcpName = "jetbrains";
const opencodeJetBrainsMcpConfig = {
  type: "remote",
  url: "http://127.0.0.1:64344/sse",
  headers: {},
  enabled: true
};

function buildPartialsForTarget(basePartials, target, outputPath) {
  const partials = new Map();
  for (const [name, partial] of basePartials.entries()) {
    let content = partial.content;
    if (content) {
      content = rewriteMarkdownLinks(content, partial.path, outputPath);
    }
    partials.set(name, content);
  }
  return partials;
}

async function loadRenderContext() {
  const [basePartials, defaultEdition, compilationTemplate] = await Promise.all([
    loadPartials(),
    detectEdition(),
    readFile(compilationTemplatePath, "utf8"),
  ]);
  return {basePartials, defaultEdition, compilationTemplate};
}

function toOpenCodeServer(name, server) {
  if (!server || typeof server !== "object") {
    throw new Error(`Invalid MCP server config for ${name}.`);
  }
  if (server.type === "stdio") {
    if (!server.command) {
      throw new Error(`MCP server ${name} is missing command.`);
    }
    const command = [server.command, ...(server.args ?? [])].filter(Boolean);
    const entry = { type: "local", command };
    if (server.env && Object.keys(server.env).length > 0) {
      entry.environment = server.env;
    }
    return entry;
  }
  if (server.type === "http") {
    if (!server.url) {
      throw new Error(`MCP server ${name} is missing url.`);
    }
    const entry = { type: "remote", url: server.url };
    if (server.headers && Object.keys(server.headers).length > 0) {
      entry.headers = server.headers;
    }
    return entry;
  }
  throw new Error(`Unsupported MCP server type for ${name}: ${server.type}`);
}

async function renderOpenCodeConfig() {
  let raw;
  try {
    raw = await readFile(mcpConfigPath, "utf8");
  } catch (error) {
    if (error && error.code === "ENOENT") {
      return;
    }
    throw error;
  }
  let parsed;
  try {
    parsed = /** @type {{mcpServers?: Record<string, unknown>}} */ (JSON.parse(raw));
  } catch (error) {
    throw new Error(`Failed to parse ${mcpConfigPath}.`);
  }
  const mcpServers = parsed.mcpServers;
  if (!mcpServers || typeof mcpServers !== "object") {
    throw new Error(`Invalid ${mcpConfigPath}: missing mcpServers.`);
  }
  const mcp = {};
  for (const [name, server] of Object.entries(mcpServers)) {
    mcp[name] = toOpenCodeServer(name, server);
  }
  if (!mcp[opencodeJetBrainsMcpName]) {
    mcp[opencodeJetBrainsMcpName] = {...opencodeJetBrainsMcpConfig};
  }
  const opencodeConfig = {
    "$schema": "https://opencode.ai/config.json",
    model: "openai/gpt-5.2-codex",
    provider: {
      openai: {
        models: {
          "gpt-5.2-codex": {
            options: {
              reasoningEffort: "high"
            }
          }
        }
      }
    },
    mcp
  };
  const content = `${JSON.stringify(opencodeConfig, null, 2)}\n`;
  await writeFile(opencodeConfigPath, content, "utf8");
}

async function copyDirectory(sourceDir, targetDir) {
  await mkdir(targetDir, {recursive: true});
  const entries = await readdir(sourceDir, {withFileTypes: true});
  for (const entry of entries) {
    const sourcePath = join(sourceDir, entry.name);
    const targetPath = join(targetDir, entry.name);
    if (entry.isDirectory()) {
      await copyDirectory(sourcePath, targetPath);
    } else if (entry.isFile()) {
      await copyFile(sourcePath, targetPath);
    }
  }
}

async function renderOpenCodeSkills() {
  let entries;
  try {
    entries = await readdir(codexSkillsDir, {withFileTypes: true});
  } catch (error) {
    if (error && error.code === "ENOENT") {
      return;
    }
    throw error;
  }

  await mkdir(opencodeSkillsDir, {recursive: true});
  const sourceSkillNames = new Set(entries.filter(entry => entry.isDirectory()).map(entry => entry.name));

  const targetEntries = await readdir(opencodeSkillsDir, {withFileTypes: true});
  for (const entry of targetEntries) {
    if (!sourceSkillNames.has(entry.name)) {
      await rm(join(opencodeSkillsDir, entry.name), {recursive: true, force: true});
    }
  }

  for (const entry of entries) {
    if (!entry.isDirectory()) {
      continue;
    }
    const sourcePath = join(codexSkillsDir, entry.name);
    const targetPath = join(opencodeSkillsDir, entry.name);
    await rm(targetPath, {recursive: true, force: true});
    await copyDirectory(sourcePath, targetPath);
  }
}

/**
 * Collects skill directories that contain a SKILL.md file.
 * Returns Map<dirName, {skillPath, content, frontmatter, isGenerated}>.
 */
async function collectSkillSources(dir) {
  let entries;
  try {
    entries = await readdir(dir, {withFileTypes: true});
  } catch (error) {
    if (error && error.code === "ENOENT") {
      return new Map();
    }
    throw error;
  }
  const skills = new Map();
  for (const entry of entries) {
    if (!entry.isDirectory()) {
      continue;
    }

    const skillPath = join(dir, entry.name, "SKILL.md");
    let content;
    try {
      content = await readFile(skillPath, "utf8");
    } catch (error) {
      if (error && error.code === "ENOENT") {
        continue;
      }
      throw error;
    }

    skills.set(entry.name, {
      skillPath,
      content,
      frontmatter: extractFrontmatter(content),
      isGenerated: content.includes(generatedSkillMarker),
    });
  }
  return skills;
}

/**
 * Extracts YAML frontmatter block (including delimiters) from content.
 */
function extractFrontmatter(content) {
  const normalizedContent = content.replace(/^\uFEFF/, "").replace(/\r\n/g, "\n");
  const match = normalizedContent.match(/^(---\n[\s\S]*?\n---(?:\n|$))/);
  if (!match) {
    return null;
  }
  const frontmatter = match[1];
  return frontmatter.endsWith("\n") ? frontmatter : `${frontmatter}\n`;
}

/**
 * Writes a skill stub SKILL.md that points to the source skill file.
 */
async function writeSkillStub(targetDir, skillDirName, frontmatter, sourcePath) {
  const skillDir = join(targetDir, skillDirName);
  await mkdir(skillDir, {recursive: true});
  const targetPath = join(skillDir, "SKILL.md");
  const relSource = toPosixPath(relative(repoRoot, sourcePath));
  const relLink = toPosixPath(relative(skillDir, sourcePath));
  const stub = `${frontmatter}${generatedSkillMarker}; edit ${relSource} -->\n\nThe skill instructions are in [SKILL.md](${relLink}).\n`;
  await writeFile(targetPath, stub, "utf8");
}

async function isGeneratedSkillStub(skillPath) {
  let content;
  try {
    content = await readFile(skillPath, "utf8");
  } catch (error) {
    if (error && error.code === "ENOENT") {
      return false;
    }
    throw error;
  }
  return content.includes(generatedSkillMarker);
}

async function pruneGeneratedSkillDirs(targetDir, expectedNames) {
  let entries;
  try {
    entries = await readdir(targetDir, {withFileTypes: true});
  } catch (error) {
    if (error && error.code === "ENOENT") {
      return;
    }
    throw error;
  }
  for (const entry of entries) {
    if (!entry.isDirectory() || expectedNames.has(entry.name)) {
      continue;
    }
    const skillPath = join(targetDir, entry.name, "SKILL.md");
    if (await isGeneratedSkillStub(skillPath)) {
      await rm(join(targetDir, entry.name), {recursive: true, force: true});
    }
  }
}

export async function renderSkills(options = {}) {
  const {
    communitySourceDir = communitySkillsSourceDir,
    agentsDir = agentsSkillsDir,
    claudeDir = claudeSkillsDir,
    communityClaudeDir = communityClaudeSkillsDir,
    edition,
  } = options;
  const normalizedEdition = edition === undefined ? await detectEdition() : normalizeEdition(edition);

  const communitySkills = await collectSkillSources(communitySourceDir);
  const communityTargets = [agentsDir, claudeDir, communityClaudeDir];

  // Collect Ultimate-only skills before pass 1 overwrites generated stubs in .agents/skills.
  const agentsSkills = await collectSkillSources(agentsDir);
  const ultimateOnlySkills = new Map();
  for (const [dirName, {skillPath, frontmatter, isGenerated}] of agentsSkills) {

    // Manual .agents/skills files are authoritative ultimate-only sources.
    // Name collisions with community source skills must fail fast to prevent overwrites.
    if (communitySkills.has(dirName)) {
      if (!isGenerated) {
        throw new Error(
          `Skill name collision for '${dirName}': community source and manual .agents/skills source both exist (${skillPath}).`,
        );
      }
      continue;
    }
    if (isGenerated) {
      continue;
    }
    if (!frontmatter) {
      throw new Error(`Invalid ultimate skill source ${skillPath}: missing YAML frontmatter.`);
    }
    ultimateOnlySkills.set(dirName, {frontmatter, skillPath});
  }

  for (const {skillPath, frontmatter} of communitySkills.values()) {
    if (!frontmatter) {
      throw new Error(`Invalid community skill source ${skillPath}: missing YAML frontmatter.`);
    }
  }

  const communitySkillNames = new Set(communitySkills.keys());
  const claudeExpectedSkillNames = normalizedEdition === "ULTIMATE"
    ? new Set([...communitySkillNames, ...ultimateOnlySkills.keys()])
    : new Set(communitySkillNames);

  // Remove stale generated stubs no longer represented by current sources.
  await pruneGeneratedSkillDirs(agentsDir, communitySkillNames);
  await pruneGeneratedSkillDirs(claudeDir, claudeExpectedSkillNames);
  await pruneGeneratedSkillDirs(communityClaudeDir, communitySkillNames);

  // Pass 1: Community skills â†’ .agents/skills/, .claude/skills/, community/.claude/skills/
  for (const [dirName, {skillPath: sourcePath, frontmatter}] of communitySkills) {
    for (const targetDir of communityTargets) {
      await writeSkillStub(targetDir, dirName, frontmatter, sourcePath);
    }
  }

  // Pass 2: Ultimate-only skills (in .agents/skills/, not generated)
  if (normalizedEdition === "ULTIMATE") {
    for (const [dirName, {frontmatter, skillPath}] of ultimateOnlySkills) {
      await writeSkillStub(claudeDir, dirName, frontmatter, skillPath);
    }
  }
}

async function main() {
  const {basePartials, defaultEdition, compilationTemplate} = await loadRenderContext();

  for (const target of outputs) {
    if (!shouldRenderTarget(target, defaultEdition)) {
      continue;
    }
    const edition = resolveEdition(target, defaultEdition);
    const outputPath = join(repoRoot, target.output);
    const templatePath = target.templatePath
      ? join(repoRoot, target.templatePath)
      : join(templatesDir, target.template);
    const templateText = await readFile(templatePath, "utf8");
    const rewrittenTemplateText = rewriteMarkdownLinks(templateText, templatePath, outputPath);
    const usesCompilationRule = target.usesCompilationRule !== false;
    if (usesCompilationRule) {
      if (!templateText.includes("{{COMPILATION_RULE}}")) {
        throw new Error(`${target.name} template is missing {{COMPILATION_RULE}} placeholder.`);
      }
    } else if (templateText.includes("{{COMPILATION_RULE}}")) {
      throw new Error(`${target.name} template includes {{COMPILATION_RULE}} but usesCompilationRule is false.`);
    }

    const partials = buildPartialsForTarget(basePartials, target, outputPath);
    const withPartials = applyPartials(rewrittenTemplateText, partials);
    if (partialPatternCheck.test(withPartials)) {
      throw new Error(`${target.name} rendered output still has {{PARTIAL:...}} placeholders.`);
    }

    const withForbiddenTools = replaceAll(
      withPartials,
      "{{FORBIDDEN_TOOLS_SUFFIX}}",
      target.forbiddenToolsSuffix,
    );
    if (withForbiddenTools.includes("{{FORBIDDEN_TOOLS_SUFFIX}}")) {
      throw new Error(`${target.name} rendered output still has {{FORBIDDEN_TOOLS_SUFFIX}} placeholder.`);
    }

    let renderedText = withForbiddenTools;
    if (usesCompilationRule) {
      const compilationRule = renderCompilationRule(compilationTemplate, target.runContext);
      renderedText = replaceAll(withForbiddenTools, "{{COMPILATION_RULE}}", compilationRule);
    }

    const withToolBlocks = applyToolBlocks(renderedText, target.tool);
    const withEditionBlocks = applyEditionBlocks(withToolBlocks, edition);
    const withoutTemplateBlocks = stripTemplateBlocks(withEditionBlocks);
    assertNoUnresolvedTemplateDirectives(withoutTemplateBlocks, target.name);

    if (withoutTemplateBlocks.includes("{{COMPILATION_RULE}}")) {
      throw new Error(`${target.name} rendered output still has {{COMPILATION_RULE}} placeholder.`);
    }

    let finalText = withoutTemplateBlocks;
    if (target.generatedHeader && !finalText.includes(target.generatedHeader)) {
      if (target.generatedHeaderPosition === "after-frontmatter" && finalText.startsWith("---\n")) {
        const frontmatterEnd = finalText.indexOf("\n---\n", 4);
        if (frontmatterEnd !== -1) {
          const insertAt = frontmatterEnd + "\n---\n".length;
          const remainder = finalText.slice(insertAt);
          const remainderStripped = remainder.startsWith("\n") ? remainder.slice(1) : remainder;
          finalText = finalText.slice(0, insertAt) + "\n" + target.generatedHeader + remainderStripped;
        } else {
          finalText = target.generatedHeader + finalText;
        }
      } else {
        finalText = target.generatedHeader + finalText;
      }
    }

    await writeFile(outputPath, normalize(finalText), "utf8");
  }

  await renderOpenCodeConfig();
  await renderOpenCodeSkills();
  await renderSkills({edition: defaultEdition});
}

function shouldRenderTarget(target, edition) {
  if (!target.onlyWhenEdition) {
    return true;
  }
  return normalizeEdition(target.onlyWhenEdition) === edition;
}

function resolveEdition(target, fallbackEdition) {
  if (!target.edition) {
    return fallbackEdition;
  }
  return normalizeEdition(target.edition);
}

const executedPath = process["argv"]?.[1];
if (executedPath && resolve(executedPath) === __filename) {
  await main();
}
